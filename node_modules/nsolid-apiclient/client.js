'use strict'

const normalizeEndpoint = require('./lib/normalize-endpoint')

module.exports = Client

// TODO: request timeouts
// const REQUEST_TIMEOUT = 10 * 1000 // 10 seconds

// TODO eventually this will be https-only
const hyperquest = require('hyperquest')

const bole = require('bole')
const logger = bole(process.title)('nsolid-apiclient')
const commands = require('./commands')
const getParams = require('./params')
const execCommands = commands.execCommands
const readCommands = commands.readCommands
const writeCommands = commands.writeCommands

function Client (endpoint, version) {
  if (!(this instanceof Client)) {
    return new Client(endpoint, version)
  }

  this.endpoint = normalizeEndpoint(endpoint, version)
  logger.debug('API Client initialized with endpoint %s', this.endpoint)
}

Client.prototype.write = function write (command, options) {
  if (!writeCommands.has(command)) {
    throw new Error(`Invalid: '${command}' is not a valid write endpoint.`)
  }

  if (options == null || options.body == null) {
    throw new Error('write requires a `options.body`')
  }

  return this._sendBody('PUT', command, options)
}

Client.prototype.exec = function exec (command, options) {
  // test command is valid
  if (!execCommands.has(command)) {
    throw new Error(`Invalid: '${command}' is not a valid command.`)
  }

  return this._sendBody('POST', command, options)
}

Client.prototype._sendBody = function _sendBody (method, command, options) {
  var opts = {
    method: method,
    rejectUnauthorized: false
  }
  // send, handle stream
  // TODO: manually work-around incomplete hyperquest timeout
  const url = this.getUrl(command, options)
  logger.debug('%s %s', opts.method, url)
  const req = hyperquest(url, opts)

  // borrowed from client-request
  var body
  var isStream = false
  if (options && options.body != null) {
    if (typeof options.body === 'string' || Buffer.isBuffer(options.body)) {
      logger.debug('Detected simple body')
      body = options.body
    } else if (options.body.pipe != null && (typeof options.body.pipe === 'function')) {
      // Stream duck typing
      logger.debug('Detected stream body')
      body = options.body
      isStream = true
    } else {
      logger.debug('Detected object body, will JSON-serialize')
      body = JSON.stringify(options.body)
    }
  }

  if (isStream) {
    logger.debug('sending stream body')
    body.pipe(req)
  } else {
    if (body != null) {
      logger.debug('data:', body)
      req.write(body)
    }
    req.end()
  }

  return req
}

// TODO un-copypasta
Client.prototype.read = function read (command, options) {
  // test command is valid
  if (!readCommands.has(command)) {
    throw new Error(`Invalid: '${command}' is not a valid request.`)
  }
  var opts = {
    method: 'GET',
    rejectUnauthorized: false
  }

  // send, handle stream
  // TODO: manually work-around incomplete hyperquest timeout
  const url = this.getUrl(command, options)
  logger.debug('getting %s', url)
  return hyperquest(url, opts)
}

Client.prototype.getUrl = function getUrl (command, options) {
  const params = getParams(command, options)
  if (params.length === 0) {
    return this.endpoint + command
  }
  return this.endpoint + command + '?' + params
}
